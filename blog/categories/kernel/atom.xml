<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kernel | Weizhenwei's Technical Blog]]></title>
  <link href="http://weizhenwei.github.io/blog/categories/kernel/atom.xml" rel="self"/>
  <link href="http://weizhenwei.github.io/"/>
  <updated>2014-12-08T23:15:49+08:00</updated>
  <id>http://weizhenwei.github.io/</id>
  <author>
    <name><![CDATA[Weizhenwei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux 系统调用实现-以read为例]]></title>
    <link href="http://weizhenwei.github.io/blog/2014/12/08/linux-xi-tong-diao-yong-shi-xian-yi-sys-readwei-li/"/>
    <updated>2014-12-08T21:52:21+08:00</updated>
    <id>http://weizhenwei.github.io/blog/2014/12/08/linux-xi-tong-diao-yong-shi-xian-yi-sys-readwei-li</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;Linux系统调用是连接用户态和内核态的纽带，弄清楚这个过程对于理解Linux操作系统具有十分重要的意义。下面以read系统调用为例分析这一过程。本文中Linux内核代码版本为3.16，glibc版本为2.20。</p>

<h3>1. sys_read函数的定义(fs/read_write.c):</h3>

<pre><code class="c">    SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)  
    {  
        struct fd f = fdget_pos(fd);  
        ssize_t ret = -EBADF;  

        if (f.file) {  
            loff_t pos = file_pos_read(f.file);  
            ret = vfs_read(f.file, buf, count, &amp;pos);  
            if (ret &gt;= 0)  
                file_pos_write(f.file, pos);  
            fdput_pos(f);  
        }  
        return ret;  
    }  
</code></pre>
]]></content>
  </entry>
  
</feed>
