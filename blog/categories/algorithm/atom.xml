<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Weizhenwei's Technical Blog]]></title>
  <link href="http://weizhenwei.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://weizhenwei.github.io/"/>
  <updated>2015-09-22T23:45:13+08:00</updated>
  <id>http://weizhenwei.github.io/</id>
  <author>
    <name><![CDATA[Weizhenwei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[On Recursion and Iteration in Algorithm]]></title>
    <link href="http://weizhenwei.github.io/blog/2015/09/22/on-recursion-and-iteration-in-algorithm/"/>
    <updated>2015-09-22T22:59:40+08:00</updated>
    <id>http://weizhenwei.github.io/blog/2015/09/22/on-recursion-and-iteration-in-algorithm</id>
    <content type="html"><![CDATA[<p>&emsp;&emsp;本文是刷leetcode的一点心得。</p>

<h3>1 算法设计领域的迭代和递归</h3>

<p>&emsp;&emsp;在计算机程序设计或者算法设计领域，迭代和递归在本质上是一致的：
每次递归或迭代是为了解决原问题的子问题，然后根据子问题的结果和当前问题的状态
综合求解当前问题。所不同的是：在递归方法中，先求得子问题的解，然后接合当前
状态求得问题结果。而在迭代方法中，使用栈保存当前问题的求解状态，然后把当前问题
分解为子问题，并把当前状态和子问题入栈；接下来对栈中的元素迭代求解，并记录最终
结果的中间状态，直到栈为空，此时返回最终的求解结果。<br/>
&emsp;&emsp;对于很多问题，用递归的方法很容易就容易解决，而用迭代的方法则不那么
直观，甚至感觉难以下手。这是因为在递归方法中，保存中间结果和栈的操作都交由函数
调用去实现了，而在迭代方法中，这些都需要在算法中手动处理。不过，只要能认识到递归
和函数其实是一样的，那么就可以很自信的说：能用递归解决的问题就一定能用迭代解决。<br/>
&emsp;&emsp;下面以一些leetcode中的题目为例进行分析。</p>

<h3>2 例题</h3>

<p>&emsp;&emsp;<a href="https://leetcode.com/problems/invert-binary-tree/">Invert Binary Tree</a><br/>
Recursive Version:<br/>
&#8220;`c++
    TreeNode<em> invertTreeRecursive(TreeNode</em> root) {<br/>
        if (root == NULL || (root->left == NULL &amp;&amp; root->right == NULL)) {<br/>
            return root;<br/>
        }</p>

<pre><code>    if (root-&gt;left) {  
        root-&gt;left = invertTreeRecursive(root-&gt;left);  
    }  
    if (root-&gt;right) {  
        root-&gt;right = invertTreeRecursive(root-&gt;right);  
    }  
    TreeNode *tmpNode = root-&gt;left;  
    root-&gt;left = root-&gt;right;  
    root-&gt;right = tmpNode;  
    return root;  
}  
</code></pre>

<pre><code>
Iterative Version:  
</code></pre>

<pre><code>TreeNode* invertTreeIterative(TreeNode* root) {  
    if (root == NULL || (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)) {  
        return root;  
    }  

    stack&lt;TreeNode*&gt; theStack;  
    theStack.push(root);  
    while (!theStack.empty()) {  
        TreeNode *topNode = theStack.top();  
        if (topNode-&gt;left == NULL &amp;&amp; topNode-&gt;right == NULL) {  
            theStack.pop();  
        } else {  
            TreeNode *tmpNode = topNode-&gt;left;  
            topNode-&gt;left = topNode-&gt;right;  
            topNode-&gt;right = tmpNode;  

            theStack.pop();  
            if (topNode-&gt;left) {  
                theStack.push(topNode-&gt;left);  
            }  
            if (topNode-&gt;right) {  
                theStack.push(topNode-&gt;right);  
            }  
        }  
    }  // while  

    return root;  
}  
</code></pre>

<p>&#8220;`</p>

<h3>3 结论</h3>

<p>&emsp;&emsp;能用递归解决的问题，就一定能用迭代解决。</p>
]]></content>
  </entry>
  
</feed>
